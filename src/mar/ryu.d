/**
A floating point to string algorithm by Ulf Adams

https://github.com/ulfjack/ryu
*/
module mar.ryu;

// (f2s: 9 digits are sufficient for round-tripping.)
// (d2fixed: We print 9-digit blocks.)
private auto decimalLength9(const uint v)
in { assert(v < 1000000000); } do
{
    if (v >= 100000000) { return 9; }
    if (v >= 10000000) { return 8; }
    if (v >= 1000000) { return 7; }
    if (v >= 100000) { return 6; }
    if (v >= 10000) { return 5; }
    if (v >= 1000) { return 4; }
    if (v >= 100) { return 3; }
    if (v >= 10) { return 2; }
    return 1;
}

// (17 digits are sufficient for round-tripping.)
private auto decimalLength17(const ulong v)
in { assert(v < 100000000000000000L); } do
{
  // This is slightly faster than a loop.
  // The average output length is 16.38 digits, so we check high-to-low.
  if (v >= 10000000000000000L) { return 17; }
  if (v >= 1000000000000000L) { return 16; }
  if (v >= 100000000000000L) { return 15; }
  if (v >= 10000000000000L) { return 14; }
  if (v >= 1000000000000L) { return 13; }
  if (v >= 100000000000L) { return 12; }
  if (v >= 10000000000L) { return 11; }
  if (v >= 1000000000L) { return 10; }
  if (v >= 100000000L) { return 9; }
  if (v >= 10000000L) { return 8; }
  if (v >= 1000000L) { return 7; }
  if (v >= 100000L) { return 6; }
  if (v >= 10000L) { return 5; }
  if (v >= 1000L) { return 4; }
  if (v >= 100L) { return 3; }
  if (v >= 10L) { return 2; }
  return 1;
}

// This approximation works up to the point that the multiplication overflows at e = 3529.
// If the multiplication were done in 64 bits, it would fail at 5^4004 which is just greater
// than 2^9297.
// Returns e == 0 ? 1 : ceil(log_2(5^e)).
auto pow5bits(const int e)
in { assert(e >= 0); assert(e <= 3528); } do
{
    pragma(inline, true);
    return cast(int) ((((cast(uint) e) * 1217359) >> 19) + 1);
}

// The first value this approximation fails for is 2^1651 which is just greater than 10^297.
// Returns floor(log_10(2^e)).
private uint log10Pow2(const int e)
in { assert(e >= 0); assert(e <= 1650); } do
{
    pragma(inline, true);
    return ((cast(uint) e) * 78913) >> 18;
}

// The first value this approximation fails for is 5^2621 which is just greater than 10^1832.
// Returns floor(log_10(5^e)).
private uint log10Pow5(const int e)
in { assert(e >= 0); assert(e <= 2620); } do
{
    pragma(inline, true);
    return ((cast(uint) e) * 732923) >> 20;
}

private ubyte copySpecialStr(char* result, const bool sign, const bool exponent, const bool mantissa)
{
    import mar.array : acopy;
    if (mantissa)
    {
        acopy(result, "NaN");
        return 3;
    }
    if (sign)
        result[0] = '-';

    if (exponent)
    {
        acopy(result + cast(ubyte)sign, "Infinity");
        return sign + 8;
    }
    acopy(result + sign, "0E0");
    return sign + 3;
}

private uint floatToBits(const float f)
{
    pragma(inline, true);
    return (cast(uint*)&f)[0];
}
private float bitsToFloat(uint bits)
{
    pragma(inline, true);
    return (cast(float*)&bits)[0];
}

private ulong doubleToBits(const double d)
{
    return (cast(ulong*)&d)[0];
}

// A table of all two-digit numbers. This is used to speed up decimal digit
// generation by copying pairs of digits into the final output.
private immutable char[200] DIGIT_TABLE = [
  '0','0','0','1','0','2','0','3','0','4','0','5','0','6','0','7','0','8','0','9',
  '1','0','1','1','1','2','1','3','1','4','1','5','1','6','1','7','1','8','1','9',
  '2','0','2','1','2','2','2','3','2','4','2','5','2','6','2','7','2','8','2','9',
  '3','0','3','1','3','2','3','3','3','4','3','5','3','6','3','7','3','8','3','9',
  '4','0','4','1','4','2','4','3','4','4','4','5','4','6','4','7','4','8','4','9',
  '5','0','5','1','5','2','5','3','5','4','5','5','5','6','5','7','5','8','5','9',
  '6','0','6','1','6','2','6','3','6','4','6','5','6','6','6','7','6','8','6','9',
  '7','0','7','1','7','2','7','3','7','4','7','5','7','6','7','7','7','8','7','9',
  '8','0','8','1','8','2','8','3','8','4','8','5','8','6','8','7','8','8','8','9',
  '9','0','9','1','9','2','9','3','9','4','9','5','9','6','9','7','9','8','9','9'
];


enum FLOAT_MANTISSA_BITS = 23;
enum FLOAT_EXPONENT_BITS = 8;
enum FLOAT_BIAS = 127;

// This table is generated by PrintFloatLookupTable.
enum FLOAT_POW5_INV_BITCOUNT = 59;
private immutable ulong[31] FLOAT_POW5_INV_SPLIT = [
  576460752303423489u, 461168601842738791u, 368934881474191033u, 295147905179352826u,
  472236648286964522u, 377789318629571618u, 302231454903657294u, 483570327845851670u,
  386856262276681336u, 309485009821345069u, 495176015714152110u, 396140812571321688u,
  316912650057057351u, 507060240091291761u, 405648192073033409u, 324518553658426727u,
  519229685853482763u, 415383748682786211u, 332306998946228969u, 531691198313966350u,
  425352958651173080u, 340282366920938464u, 544451787073501542u, 435561429658801234u,
  348449143727040987u, 557518629963265579u, 446014903970612463u, 356811923176489971u,
  570899077082383953u, 456719261665907162u, 365375409332725730u
];
enum FLOAT_POW5_BITCOUNT = 61;
private immutable ulong[47] FLOAT_POW5_SPLIT = [
  1152921504606846976u, 1441151880758558720u, 1801439850948198400u, 2251799813685248000u,
  1407374883553280000u, 1759218604441600000u, 2199023255552000000u, 1374389534720000000u,
  1717986918400000000u, 2147483648000000000u, 1342177280000000000u, 1677721600000000000u,
  2097152000000000000u, 1310720000000000000u, 1638400000000000000u, 2048000000000000000u,
  1280000000000000000u, 1600000000000000000u, 2000000000000000000u, 1250000000000000000u,
  1562500000000000000u, 1953125000000000000u, 1220703125000000000u, 1525878906250000000u,
  1907348632812500000u, 1192092895507812500u, 1490116119384765625u, 1862645149230957031u,
  1164153218269348144u, 1455191522836685180u, 1818989403545856475u, 2273736754432320594u,
  1421085471520200371u, 1776356839400250464u, 2220446049250313080u, 1387778780781445675u,
  1734723475976807094u, 2168404344971008868u, 1355252715606880542u, 1694065894508600678u,
  2117582368135750847u, 1323488980084844279u, 1654361225106055349u, 2067951531382569187u,
  1292469707114105741u, 1615587133892632177u, 2019483917365790221u
];

private uint pow5Factor(uint value)
{
    uint count = 0;
    for (;;count++)
    {
        assert(value != 0);
        const q = value / 5;
        const r = value % 5;
        if (r != 0)
            break;

        value = q;
    }
    return count;
}

// Returns true if value is divisible by 5^p.
private bool multipleOfPowerOf5(const uint value, const uint p)
{
    pragma(inline, true);
    return pow5Factor(value) >= p;
}

// Returns true if value is divisible by 2^p.
private bool multipleOfPowerOf2(const uint value, const uint p)
{
    pragma(inline, true);
    // return __builtin_ctz(value) >= p;
    return (value & ((1u << p) - 1)) == 0;
}

// It seems to be slightly faster to avoid uint128_t here, although the
// generated code for uint128_t looks slightly nicer.
private uint mulShift(const uint m, const ulong factor, const int shift)
{
    assert(shift > 32);

    // The casts here help MSVC to avoid calls to the __allmul library
    // function.
    const factorLo = cast(uint)(factor);
    const factorHi = cast(uint)(factor >> 32);
    const bits0 = cast(ulong)m * factorLo;
    const bits1 = cast(ulong)m * factorHi;

    static if (size_t.sizeof == 4)
    {
        // On 32-bit platforms we can avoid a 64-bit shift-right since we only
        // need the upper 32 bits of the result and the shift value is > 32.
        const bits0Hi = cast(uint)(bits0 >> 32);
        uint bits1Lo = cast(uint)(bits1);
        uint bits1Hi = cast(uint)(bits1 >> 32);
        bits1Lo += bits0Hi;
        bits1Hi += (bits1Lo < bits0Hi);
        const int s = shift - 32;
        return (bits1Hi << (32 - s)) | (bits1Lo >> s);
    }
    else
    {
        const ulong sum = (bits0 >> 32) + bits1;
        const ulong shiftedSum = sum >> (shift - 32);
        assert(shiftedSum <= uint.max);
        return cast(uint) shiftedSum;
    }
}

private uint mulPow5InvDivPow2(const uint m, const uint q, const int j)
{
    pragma(inline, true);
    return mulShift(m, FLOAT_POW5_INV_SPLIT[q], j);
}

private uint mulPow5divPow2(const uint m, const uint i, const int j)
{
    pragma(inline, true);
    return mulShift(m, FLOAT_POW5_SPLIT[i], j);
}

// A floating decimal representing m * 10^e.
struct FloatingDecimal32
{
    uint mantissa;
    byte exponent; // range is -45 to 38
}
// A floating decimal representing m * 10^e.
struct FloatingDecimal64
{
    ulong mantissa;
    short exponent; // range is -324 to 308 inclusive.
}

private FloatingDecimal32 f2d(const uint mantissa, const uint exponent)
{
    int e2;
    uint m2;
    if (exponent == 0)
    {
        // We subtract 2 so that the bounds computation has 2 additional bits.
        e2 = 1 - FLOAT_BIAS - FLOAT_MANTISSA_BITS - 2;
        m2 = mantissa;
    }
    else
    {
        e2 = cast(int) exponent - FLOAT_BIAS - FLOAT_MANTISSA_BITS - 2;
        m2 = (1u << FLOAT_MANTISSA_BITS) | mantissa;
    }
    const bool even = (m2 & 1) == 0;
    const bool acceptBounds = even;

    version (RyuDebug)
    {
        printf("-> %u * 2^%d\n", m2, e2 + 2);
    }

    // Step 2: Determine the interval of valid decimal representations.
    const uint mv = 4 * m2;
    const uint mp = 4 * m2 + 2;
    // Implicit bool -> int conversion. True is 1, false is 0.
    const uint mmShift = mantissa != 0 || exponent <= 1;
    const uint mm = 4 * m2 - 1 - mmShift;

    // Step 3: Convert to a decimal power base using 64-bit arithmetic.
    uint vr, vp, vm;
    int e10;
    bool vmIsTrailingZeros = false;
    bool vrIsTrailingZeros = false;
    ubyte lastRemovedDigit = 0;
    if (e2 >= 0)
    {
        const uint q = log10Pow2(e2);
        e10 = cast(int) q;
        const int k = FLOAT_POW5_INV_BITCOUNT + pow5bits(cast(int) q) - 1;
        const int i = -e2 + cast(int) q + k;
        vr = mulPow5InvDivPow2(mv, q, i);
        vp = mulPow5InvDivPow2(mp, q, i);
        vm = mulPow5InvDivPow2(mm, q, i);
        version (RyuDebug)
        {
            printf("%u * 2^%d / 10^%u\n", mv, e2, q);
            printf("V+=%u\nV =%u\nV-=%u\n", vp, vr, vm);
        }
        if (q != 0 && (vp - 1) / 10 <= vm / 10) {
            // We need to know one removed digit even if we are not going to loop below. We could use
            // q = X - 1 above, except that would require 33 bits for the result, and we've found that
            // 32-bit arithmetic is faster even on 64-bit machines.
            const int l = FLOAT_POW5_INV_BITCOUNT + pow5bits(cast(int) (q - 1)) - 1;
            lastRemovedDigit = cast(ubyte) (mulPow5InvDivPow2(mv, q - 1, -e2 + cast(int) q - 1 + l) % 10);
        }
        if (q <= 9) {
            // The largest power of 5 that fits in 24 bits is 5^10, but q <= 9 seems to be safe as well.
            // Only one of mp, mv, and mm can be a multiple of 5, if any.
            if (mv % 5 == 0) {
                vrIsTrailingZeros = multipleOfPowerOf5(mv, q);
            } else if (acceptBounds) {
                vmIsTrailingZeros = multipleOfPowerOf5(mm, q);
            } else {
                vp -= multipleOfPowerOf5(mp, q);
            }
        }
    }
    else
    {
        const uint q = log10Pow5(-e2);
        e10 = cast(int) q + e2;
        const int i = -e2 - cast(int) q;
        const int k = pow5bits(i) - FLOAT_POW5_BITCOUNT;
        int j = cast(int) q - k;
        vr = mulPow5divPow2(mv, cast(uint) i, j);
        vp = mulPow5divPow2(mp, cast(uint) i, j);
        vm = mulPow5divPow2(mm, cast(uint) i, j);
        version (RyuDebug)
        {
            printf("%u * 5^%d / 10^%u\n", mv, -e2, q);
            printf("%u %d %d %d\n", q, i, k, j);
            printf("V+=%u\nV =%u\nV-=%u\n", vp, vr, vm);
        }
        if (q != 0 && (vp - 1) / 10 <= vm / 10) {
        j = cast(int) q - 1 - (pow5bits(i + 1) - FLOAT_POW5_BITCOUNT);
        lastRemovedDigit = cast(ubyte) (mulPow5divPow2(mv, cast(uint) (i + 1), j) % 10);
        }
        if (q <= 1)
        {
            // {vr,vp,vm} is trailing zeros if {mv,mp,mm} has at least q trailing 0 bits.
            // mv = 4 * m2, so it always has at least two trailing 0 bits.
            vrIsTrailingZeros = true;
            if (acceptBounds) {
            // mm = mv - 1 - mmShift, so it has 1 trailing 0 bit iff mmShift == 1.
            vmIsTrailingZeros = mmShift == 1;
            } else {
            // mp = mv + 2, so it always has at least one trailing 0 bit.
            --vp;
            }
        }
        else if (q < 31) // TODO(ulfjack): Use a tighter bound here.
        {
            vrIsTrailingZeros = multipleOfPowerOf2(mv, q - 1);
            version (RyuDebug)
            {
                printf("vr is trailing zeros=%s\n", vrIsTrailingZeros ? "true" : "false");
            }
        }
    }
    version (RyuDebug)
    {
        printf("e10=%d\n", e10);
        printf("V+=%u\nV =%u\nV-=%u\n", vp, vr, vm);
        printf("vm is trailing zeros=%s\n", vmIsTrailingZeros ? "true" : "false");
        printf("vr is trailing zeros=%s\n", vrIsTrailingZeros ? "true" : "false");
    }

    // Step 4: Find the shortest decimal representation in the interval of valid representations.
    int removed = 0;
    uint output;
    if (vmIsTrailingZeros || vrIsTrailingZeros) {
        // General case, which happens rarely (~4.0%).
        while (vp / 10 > vm / 10) {
            //// #ifdef __clang__ // https://bugs.llvm.org/show_bug.cgi?id=23106
            //// // The compiler does not realize that vm % 10 can be computed from vm / 10
            //// // as vm - (vm / 10) * 10.
            //// vmIsTrailingZeros &= vm - (vm / 10) * 10 == 0;
            //// #else
            vmIsTrailingZeros &= vm % 10 == 0;
            //// #endif
            vrIsTrailingZeros &= lastRemovedDigit == 0;
            lastRemovedDigit = cast(ubyte) (vr % 10);
            vr /= 10;
            vp /= 10;
            vm /= 10;
            ++removed;
        }
        version (RyuDebug)
        {
            printf("V+=%u\nV =%u\nV-=%u\n", vp, vr, vm);
            printf("d-10=%s\n", vmIsTrailingZeros ? "true" : "false");
        }
        if (vmIsTrailingZeros) {
            while (vm % 10 == 0) {
                vrIsTrailingZeros &= lastRemovedDigit == 0;
                lastRemovedDigit = cast(ubyte) (vr % 10);
                vr /= 10;
                vp /= 10;
                vm /= 10;
                ++removed;
            }
        }
        version (RyuDebug)
        {
            printf("%u %d\n", vr, lastRemovedDigit);
            printf("vr is trailing zeros=%s\n", vrIsTrailingZeros ? "true" : "false");
        }
        if (vrIsTrailingZeros && lastRemovedDigit == 5 && vr % 2 == 0) {
            // Round even if the exact number is .....50..0.
            lastRemovedDigit = 4;
        }
        // We need to take vr + 1 if vr is outside bounds or we need to round up.
        output = vr + ((vr == vm && (!acceptBounds || !vmIsTrailingZeros)) || lastRemovedDigit >= 5);
    } else {
        // Specialized for the common case (~96.0%). Percentages below are relative to this.
        // Loop iterations below (approximately):
        // 0: 13.6%, 1: 70.7%, 2: 14.1%, 3: 1.39%, 4: 0.14%, 5+: 0.01%
        while (vp / 10 > vm / 10) {
            lastRemovedDigit = cast(ubyte) (vr % 10);
            vr /= 10;
            vp /= 10;
            vm /= 10;
            ++removed;
        }
        version (RyuDebug)
        {
            printf("%u %d\n", vr, lastRemovedDigit);
            printf("vr is trailing zeros=%s\n", vrIsTrailingZeros ? "true" : "false");
        }
        // We need to take vr + 1 if vr is outside bounds or we need to round up.
        output = vr + (vr == vm || lastRemovedDigit >= 5);
    }
    const int exp = e10 + removed;

    version (RyuDebug)
    {
        printf("V+=%u\nV =%u\nV-=%u\n", vp, vr, vm);
        printf("O=%u\n", output);
        printf("EXP=%d\n", exp);
    }

    FloatingDecimal32 fd;
    assert(exp >= -45 && exp <= 38);
    fd.exponent = cast(byte)exp;
    fd.mantissa = output;
    return fd;
}

private ubyte toChars(const FloatingDecimal32 v, const bool sign, char* result)
{
    import mar.mem : memcpy;

    // Step 5: Print the decimal representation.
    ubyte index = 0;
    if (sign)
        result[index++] = '-';

    uint output = v.mantissa;
    const uint olength = decimalLength9(output);

    version (RyuDebug)
    {
        printf("DIGITS=%u\n", v.mantissa);
        printf("OLEN=%u\n", olength);
        printf("EXP=%u\n", v.exponent + olength);
    }

    // Print the decimal digits.
    // The following code is equivalent to:
    // for (uint i = 0; i < olength - 1; ++i) {
    //   const uint c = output % 10; output /= 10;
    //   result[index + olength - i] = (char) ('0' + c);
    // }
    // result[index] = '0' + output % 10;
    uint i = 0;
    while (output >= 10000)
    {
        //// #ifdef __clang__ // https://bugs.llvm.org/show_bug.cgi?id=38217
        //// const uint c = output - 10000 * (output / 10000);
        //// #else
        const uint c = output % 10000;
        //// #endif
        output /= 10000;
        const uint c0 = (c % 100) << 1;
        const uint c1 = (c / 100) << 1;
        memcpy(result + index + olength - i - 1, DIGIT_TABLE.ptr + c0, 2);
        memcpy(result + index + olength - i - 3, DIGIT_TABLE.ptr + c1, 2);
        i += 4;
    }
    if (output >= 100)
    {
        const uint c = (output % 100) << 1;
        output /= 100;
        memcpy(result + index + olength - i - 1, DIGIT_TABLE.ptr + c, 2);
        i += 2;
    }
    if (output >= 10)
    {
        const uint c = output << 1;
        // We can't use memcpy here: the decimal dot goes between these two digits.
        result[index + olength - i] = DIGIT_TABLE[c + 1];
        result[index] = DIGIT_TABLE[c];
    }
    else
    {
        result[index] = cast(char) ('0' + output);
    }

    // Print decimal point if needed.
    if (olength > 1)
    {
        result[index + 1] = '.';
        index += olength + 1;
    }
    else
    {
        ++index;
    }

    // Print the exponent.
    result[index++] = 'E';
    int exp = v.exponent + cast(int) olength - 1;
    if (exp < 0)
    {
        result[index++] = '-';
        exp = -exp;
    }

    if (exp >= 10)
    {
        memcpy(result + index, DIGIT_TABLE.ptr + 2 * exp, 2);
        index += 2;
    }
    else
    {
        result[index++] = cast(char) ('0' + exp);
    }

    return index;
}

ubyte floatToString(float f, char* result)
{
    // Step 1: Decode the floating-point number, and unify normalized and subnormal cases.
    const bits = floatToBits(f);

    version (RyuDebug)
    {
        printf("IN=");
        for (int bit = 31; bit >= 0; --bit)
        {
            printf("%u", (bits >> bit) & 1);
        }
        printf("\n");
    }

    // Decode bits into sign, mantissa, and exponent.
    const bool ieeeSign = ((bits >> (FLOAT_MANTISSA_BITS + FLOAT_EXPONENT_BITS)) & 1) != 0;
    const uint mantissa = bits & ((1u << FLOAT_MANTISSA_BITS) - 1);
    const uint exponent = (bits >> FLOAT_MANTISSA_BITS) & ((1u << FLOAT_EXPONENT_BITS) - 1);

    // Case distinction; exit early for the easy cases.
    if (exponent == ((1u << FLOAT_EXPONENT_BITS) - 1u) || (exponent == 0 && mantissa == 0))
    {
        return copySpecialStr(result, ieeeSign, exponent != 0, mantissa != 0);
    }

    const FloatingDecimal32 v = f2d(mantissa, exponent);
    return toChars(v, ieeeSign, result);
}

unittest
{
    import mar.stdio;

    static void test(string expected, float value)
    {
        stdout.writeln("testing ", expected);
        char[100] buffer;
	const actual = buffer[0 .. floatToString(value, buffer.ptr)];
	if (actual != expected)
	{
	    stdout.writeln("expected: ", expected);
	    stdout.writeln("actual  : ", actual);
	    assert(0);
	}
    }
    test("0E0", 0.0);
    test("-0E0", -0.0);
    test("1E0", 1.0);
    test("-1E0", -1.0);
    test("NaN", float.nan);
    test("Infinity", float.infinity);
    test("-Infinity", -float.infinity);

    // SwitchToSubnormal
    test("1.1754944E-38", 1.1754944E-38f);

    // MinAndMax
    test("3.4028235E38", bitsToFloat(0x7f7fffff));
    test("1E-45", bitsToFloat(1));

    // Check that we return the exact boundary if it is the shortest
    // representation, but only if the original floating point number is even.
    test("3.355445E7", 3.355445E7f);
    test("9E9", 8.999999E9f);
    test("3.436672E10", 3.4366717E10f);

    // If the exact value is exactly halfway between two shortest representations,
    // then we round to even. It seems like this only makes a difference if the
    // last two digits are ...2|5 or ...7|5, and we cut off the 5.
    test("3.0540412E5", 3.0540412E5f);
    test("8.0990312E3", 8.0990312E3f);

    // LotsOfTrailingZeros
    // Pattern for the first test: 00111001100000000000000000000000
    test("2.4414062E-4", 2.4414062E-4f);
    test("2.4414062E-3", 2.4414062E-3f);
    test("4.3945312E-3", 4.3945312E-3f);
    test("6.3476562E-3", 6.3476562E-3f);

    // Regression
    test("4.7223665E21", 4.7223665E21f);
    test("8.388608E6", 8388608.0f);
    test("1.6777216E7", 1.6777216E7f);
    test("3.3554436E7", 3.3554436E7f);
    test("6.7131496E7", 6.7131496E7f);
    test("1.9310392E-38", 1.9310392E-38f);
    //test("-2.47E-43", -2.47E-43f);
    test("1.993244E-38", 1.993244E-38f);
    test("4.1039004E3", 4103.9003f);
    test("5.3399997E9", 5.3399997E9f);
    //test("6.0898E-39", 6.0898E-39f);
    test("1.0310042E-3", 0.0010310042f);
    test("2.882326E17", 2.8823261E17f);
  /*
#ifndef _WIN32
  // MSVC rounds this up to the next higher floating point number
    test("7.038531E-26", 7.038531E-26f);
#else
    test("7.038531E-26", 7.0385309E-26f);
#endif
*/
    test("9.223404E17", 9.2234038E17f);
    test("6.710887E7", 6.7108872E7f);
    //test("1E-44", 1.0E-44f);
    test("2.816025E14", 2.816025E14f);
    test("9.223372E18", 9.223372E18f);
    test("1.5846086E29", 1.5846085E29f);
    test("1.1811161E19", 1.1811161E19f);
    test("5.368709E18", 5.368709E18f);
    test("4.6143166E18", 4.6143165E18f);
    test("7.812537E-3", 0.007812537f);
    //test("1E-45", 1.4E-45f);
    test("1.18697725E20", 1.18697724E20f);
    test("1.00014165E-36", 1.00014165E-36f);
    test("2E2", 200.0f);
    test("3.3554432E7", 3.3554432E7f);

    // These numbers have a mantissa that is the largest power of 5 that fits,
    // and an exponent that causes the computation for q to result in 10, which is a corner
    // case for Ryu.
    test("6.7108864E17", bitsToFloat(0x5D1502F9));
    test("1.3421773E18", bitsToFloat(0x5D9502F9));
    test("2.6843546E18", bitsToFloat(0x5E1502F9));

    // OutputLength
    test("1E0", 1.0f); // already tested in Basic
    test("1.2E0", 1.2f);
    test("1.23E0", 1.23f);
    test("1.234E0", 1.234f);
    test("1.2345E0", 1.2345f);
    test("1.23456E0", 1.23456f);
    test("1.234567E0", 1.234567f);
    test("1.2345678E0", 1.2345678f);
    test("1.23456735E-36", 1.23456735E-36f);
}


enum FLOAT_MAX_CHARS = 15;

//version = VerifyMaxChars;
version (VerifyMaxChars)
unittest
{
    import mar.stdio;
    import mar.print;
    // get the max number of digits
    ubyte maxCharCount = 0;
    for (uint bits = 0;; bits++)
    {
        if ((bits & 0xFFFFFF) == 0)
	    stdout.writeln("0x", bits.formatHex, ": current max is ", maxCharCount);
        char[40] buffer = void;
	auto length = floatToString(bitsToFloat(bits), buffer.ptr);
	if (length > maxCharCount)
	    maxCharCount = length;
        if (bits == uint.max)
	    break;
    }
    stdout.writeln("max char count is ", maxCharCount);
    assert(FLOAT_MAX_CHARS == maxCharCount);
}


/*
// The string will never be very long, so our return type can be a byte
ubyte floatToString(float f, char* result)
{
    const index = f2s_buffered_n(f, result);

    // Terminate the string.
    result[index] = '\0';
    return index;
}

char* f2s(float f)
{
    char* const result = cast(char*)malloc(16);
    f2s_buffered(f, result);
    return result;
}
*/